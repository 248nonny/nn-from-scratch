
use super::*;




fn compare_equal_f(f1: F, f2: F) -> bool {
    compare_equal_f_tolerance(f1, f2, 0.00001)
}

fn compare_equal_f_tolerance(f1: F, f2: F, tolerance: F) -> bool {
    (f2 - f1).abs() < tolerance
}

#[test]
fn test_dot_product() {
    let vecs: [[F;3];4] = [
        [0.1, 0.1, 2.0],
        [1.0, 2.0, 10.0],
        [5.0, 0.213, 3.0],
        [2.75, 0.03, 1.5],
    ];

    let dots: [F;16] = [
        4.02,   20.3,   6.5213,     3.278,
        20.3,   105.0,  35.426,     17.81,
        6.5213, 35.426, 34.045369,  18.25639,
        3.278,  17.81,  18.25639,   9.8134,
    ];

    let tolerance: F = 0.00001;

    for (v1, i) in zip(vecs, 0..4) {
        for (v2, j) in zip(vecs, 0..4) {
            assert!((dot(&v1, &v2).unwrap() - dots[i + 4 * j]).abs() < tolerance);
        }
    }

    assert!(dot(&[1.0,2.0], &[1.0,2.0,3.0]) == None);

    // can we dot product array slices?
    assert!((dot(&vecs[0][0..2], &vecs[1][0..2]).unwrap() - 0.3).abs() < tolerance);
}




// ---------------------------
// NOTE: the below code was largely generated by ChatGPT, though I reviewed
// it to make sure all was well. None of the other code in this whole program was
// copied directly from ChatGPT.
// ---------------------------

/// A helper function to generate a Matrix of dimensions (n x m)
/// with sequential values starting from `start_val`.
fn generate_matrix(m: usize, n: usize, start_val: F) -> Matrix {
    let mut values = Vec::with_capacity(n * m);
    let mut current_val = start_val;
    for _ in 0..(n * m) {
        values.push(current_val);
        current_val += 1.0;
    }
    Matrix::from_values(values, m, n)
}


    /// Test `iter_row` and `iter_col` to ensure they return the correct slices.
    #[test]
    fn test_iter_row_and_col() {
        let mat = Matrix::from_values(
            [
                1.0, 2.0, 3.0,  // row 0
                4.0, 5.0, 6.0,  // row 1
            ],
            2,  // number of rows
            3,  // number of columns
        );

        // Check row 0
        let row0: Vec<_> = mat.iter_row(0).collect();
        assert_eq!(row0, vec![1.0, 2.0, 3.0]);

        // Check row 1
        let row1: Vec<_> = mat.iter_row(1).collect();
        assert_eq!(row1, vec![4.0, 5.0, 6.0]);

        // Check column 0
        let col0: Vec<_> = mat.iter_col(0).collect();
        assert_eq!(col0, vec![1.0, 4.0]);

        // Check column 2
        let col2: Vec<_> = mat.iter_col(2).collect();
        assert_eq!(col2, vec![3.0, 6.0]);
    }

    /// Test `get_row` and `get_col` methods to retrieve correct rows/columns as vectors.
    #[test]
    fn test_get_row_and_col() {
        let mat = Matrix::from_values(
            [
                1.0, 2.0, 3.0,  // row 0
                4.0, 5.0, 6.0,  // row 1
            ],
            2,  // number of rows
            3,  // number of columns
        );

        // get_row
        let row0 = mat.get_row(0);
        assert_eq!(row0, vec![1.0, 2.0, 3.0]);
        let row1 = mat.get_row(1);
        assert_eq!(row1, vec![4.0, 5.0, 6.0]);

        // get_col
        let col0 = mat.get_col(0);
        assert_eq!(col0, vec![1.0, 4.0]);
        let col2 = mat.get_col(2);
        assert_eq!(col2, vec![3.0, 6.0]);
    }

    /// Test setting an entire row using `set_row` and verify the columns are updated accordingly.
    #[test]
    fn test_set_row() {
        let mut mat = Matrix::from_values(
            [
                1.0, 2.0, 3.0,  // row 0
                4.0, 5.0, 6.0,  // row 1
            ],
            2,  // number of rows
            3,  // number of columns
        );

        // Change the first row
        mat.set_row(0, [10.0, 11.0, 12.0]);
        assert_eq!(mat.get_row(0), vec![10.0, 11.0, 12.0]); // updated
        assert_eq!(mat.get_row(1), vec![4.0, 5.0, 6.0]);    // unchanged

        // Verify that column 2 reflects the change in row 0
        let col2 = mat.get_col(2);
        assert_eq!(col2, vec![12.0, 6.0]);
    }

#[test]
fn test_vector_scaling() {
    // Test scaling for an array
    let v1 = [1.0, 2.0, 3.0];
    let scaled_v1 = v1.scale(2.0);

    assert_eq!(scaled_v1.elements().collect::<Vec<_>>(), vec![2.0, 4.0, 6.0]);

    // Test scaling for a slice
    let v2 = vec![1.0, 2.0, 3.0, 4.0];
    let scaled_v2 = v2[1..3].scale(3.0); // only 2 elements
    assert_eq!(scaled_v2.elements().collect::<Vec<_>>(), vec![6.0, 9.0]);

    // Test scaling for a full Vec
    let scaled_v2_full = v2.scale(-1.0);
    assert_eq!(scaled_v2_full.elements().collect::<Vec<_>>(), vec![-1.0, -2.0, -3.0, -4.0]);
}

#[test]
fn test_from_values() {
    // No reference needed, just pass array directly
    let mat = Matrix::from_values([1.0, 2.0, 3.0, 4.0], 2, 2);
    assert_eq!(mat.get_val(0, 0).unwrap(), 1.0);
    assert_eq!(mat.get_val(0, 1).unwrap(), 2.0);
    assert_eq!(mat.get_val(1, 0).unwrap(), 3.0);
    assert_eq!(mat.get_val(1, 1).unwrap(), 4.0);

    // Check if dimension mismatch panics (uncomment to verify panic)
    // let _ = Matrix::from_values([1.0, 2.0, 3.0], 2, 2); // should panic
}

#[test]
fn test_from_rows_and_cols() {
    // from_rows
    let row1 = [1.0, 2.0];
    let row2 = [3.0, 4.0];
    let mat_rows = Matrix::from_rows(vec![row1, row2]);
    assert_eq!(mat_rows.get_val(0, 0).unwrap(), 1.0);
    assert_eq!(mat_rows.get_val(0, 1).unwrap(), 2.0);
    assert_eq!(mat_rows.get_val(1, 0).unwrap(), 3.0);
    assert_eq!(mat_rows.get_val(1, 1).unwrap(), 4.0);

    // from_cols
    let col1 = [1.0, 3.0];
    let col2 = [2.0, 4.0];
    let mat_cols = Matrix::from_cols(vec![col1, col2]);
    assert_eq!(mat_cols.get_val(0, 0).unwrap(), 1.0);
    assert_eq!(mat_cols.get_val(0, 1).unwrap(), 2.0);
    assert_eq!(mat_cols.get_val(1, 0).unwrap(), 3.0);
    assert_eq!(mat_cols.get_val(1, 1).unwrap(), 4.0);

    // Check they are the same
    for i in 0..2 {
        for j in 0..2 {
            assert!(compare_equal_f(
                mat_rows.get_val(i, j).unwrap(),
                mat_cols.get_val(i, j).unwrap()
            ));
        }
    }
}

#[test]
fn test_matrix_transpose() {
    let mat_original = Matrix::from_values([1.0, 2.0, 3.0,
                                            4.0, 5.0, 6.0], 2, 3);
    // 3x2 matrix:
    // [1 2 3]
    // [4 5 6]

    let mat_t = mat_original.to_transpose();
    // 2x3 matrix:
    // [1 4]
    // [2 5]
    // [3 6]

    assert_eq!(mat_t.n, 2);
    assert_eq!(mat_t.m, 3);

    // check row 0 => [1, 4], row 1 => [2,5], row 2 => [3,6]
    assert_eq!(mat_t.get_val(0, 0).unwrap(), 1.0);
    assert_eq!(mat_t.get_val(0, 1).unwrap(), 4.0);

    assert_eq!(mat_t.get_val(1, 0).unwrap(), 2.0);
    assert_eq!(mat_t.get_val(1, 1).unwrap(), 5.0);

    assert_eq!(mat_t.get_val(2, 0).unwrap(), 3.0);
    assert_eq!(mat_t.get_val(2, 1).unwrap(), 6.0);
}

#[test]
fn test_matrix_new_identity() {
    for size in [1, 2, 3, 5] {
        let identity = Matrix::new_identity(size);
        assert_eq!(identity.n, size);
        assert_eq!(identity.m, size);

        for i in 0..size {
            for j in 0..size {
                if i == j {
                    assert_eq!(identity.get_val(i, j).unwrap(), 1.0);
                } else {
                    assert_eq!(identity.get_val(i, j).unwrap(), 0.0);
                }
            }
        }
    }
}

#[test]
fn test_matrix_multiplication() {
    // Simple 2x2 example
    let a = Matrix::from_values([1.0, 2.0, 3.0, 4.0], 2, 2);
    let b = Matrix::from_values([2.0, 0.0, 1.0, 2.0], 2, 2);

    // a * b = [ (1*2 + 2*1), (1*0 + 2*2),
    //           (3*2 + 4*1), (3*0 + 4*2)]
    //        = [4, 5,
    //           10, 8]
    let product = &a * &b;
    assert_eq!(product.get_val(0, 0).unwrap(), 4.0);
    assert_eq!(product.get_val(0, 1).unwrap(), 4.0);
    assert_eq!(product.get_val(1, 0).unwrap(), 10.0);
    assert_eq!(product.get_val(1, 1).unwrap(), 8.0);

    // Multiply identity
    let identity = Matrix::new_identity(2);
    let product_id = &a * &identity;
    for i in 0..2 {
        for j in 0..2 {
            assert!(compare_equal_f(
                product_id.get_val(i, j).unwrap(),
                a.get_val(i, j).unwrap()
            ));
        }
    }

    // Test dimension mismatch
    let bigger = Matrix::new(3, 3);
    // let _ = &a * &bigger; // uncomment to see panic
}

#[test]
fn test_non_square_matrix_multiplication() {
    // Matrix A (2 rows, 3 columns)
    // Row 0: [1, 2, 3]
    // Row 1: [4, 5, 6]
    let a = Matrix::from_values(
        [1.0, 2.0, 3.0,
         4.0, 5.0, 6.0],
        2, // number of rows
        3, // number of columns
    );

    // Matrix B (3 rows, 4 columns)
    // Row 0: [1,  2,  3,  4]
    // Row 1: [5,  6,  7,  8]
    // Row 2: [9, 10, 11, 12]
    let b = Matrix::from_values(
        [1.0,  2.0,  3.0,  4.0,
         5.0,  6.0,  7.0,  8.0,
         9.0, 10.0, 11.0, 12.0],
        3, // number of rows
        4, // number of columns
    );

    // The product should be 2x4:
    // A * B = (2x3) * (3x4) = (2x4)
    //
    // Manual computation shows:
    //
    // product(0,0) = dot([1,2,3], [1,5,9])   = 1 + 10 + 27   = 38
    // product(0,1) = dot([1,2,3], [2,6,10])  = 2 + 12 + 30   = 44
    // product(0,2) = dot([1,2,3], [3,7,11])  = 3 + 14 + 33   = 50
    // product(0,3) = dot([1,2,3], [4,8,12])  = 4 + 16 + 36   = 56
    //
    // product(1,0) = dot([4,5,6], [1,5,9])   = 4 + 25 + 54   = 83
    // product(1,1) = dot([4,5,6], [2,6,10])  = 8 + 30 + 60   = 98
    // product(1,2) = dot([4,5,6], [3,7,11])  = 12 + 35 + 66  = 113
    // product(1,3) = dot([4,5,6], [4,8,12])  = 16 + 40 + 72  = 128
    let product = &a * &b;

    // Check the shape of the product: 2 rows (m = a.m) x 4 columns (n = b.n)
    assert_eq!(product.m, 2);
    assert_eq!(product.n, 4);

    // Check values
    // row 0 => [38, 44, 50, 56]
    assert_eq!(product.get_val(0, 0).unwrap(), 38.0);
    assert_eq!(product.get_val(0, 1).unwrap(), 44.0);
    assert_eq!(product.get_val(0, 2).unwrap(), 50.0);
    assert_eq!(product.get_val(0, 3).unwrap(), 56.0);

    // row 1 => [83, 98, 113, 128]
    assert_eq!(product.get_val(1, 0).unwrap(), 83.0);
    assert_eq!(product.get_val(1, 1).unwrap(), 98.0);
    assert_eq!(product.get_val(1, 2).unwrap(), 113.0);
    assert_eq!(product.get_val(1, 3).unwrap(), 128.0);
}

#[test]
fn test_matrix_vector_multiplication() {
    let mat = Matrix::from_values([0.0, 1.0, 2.0, 3.0, 4.0, 5.0], 2, 3);

    let vecs = [
        [0.0, 0.0, 0.0],
        [1.0, 1.0, 1.0],
        [5.0, 3.0, 7.0]
    ];

    let expected_results = [
        [0.0, 0.0],
        [3.0, 12.0],
        [17.0, 62.0]
    ];

    for i in 0..3 {
        let output = &mat * &(vecs[i]);
        println!("input: {:?}, output: {:?}", vecs[i], output);

        for j in 0..2 {
            assert_eq!(output[j], expected_results[i][j]);
        }
    }

}

#[test]
fn test_matrix_set_and_apply_function() {
    let mut mat = Matrix::from_values([0.0, 1.0, 2.0, 3.0], 2, 2);

    // set_value
    mat.set_value(10.0, 0, 1); // set top-right
    assert_eq!(mat.get_val(0, 1).unwrap(), 10.0);

    // set_row
    mat.set_row(1, [7.0, 8.0]);
    assert_eq!(mat.get_val(1, 0).unwrap(), 7.0);
    assert_eq!(mat.get_val(1, 1).unwrap(), 8.0);

    // apply_function
    let incremented = mat.to_apply_fn(|x| x + 1.0);
    mat.apply_fn(|x| *x += 1.0);

    assert_eq!(incremented.get_val(0, 0).unwrap(), 1.0);  // was 0.0
    assert_eq!(incremented.get_val(0, 1).unwrap(), 11.0); // was 10.0
    assert_eq!(incremented.get_val(1, 0).unwrap(), 8.0);  // was 7.0
    assert_eq!(incremented.get_val(1, 1).unwrap(), 9.0);  // was 8.0
                                                          //
    assert_eq!(mat.get_val(0, 0).unwrap(), 1.0);  // was 0.0
    assert_eq!(mat.get_val(0, 1).unwrap(), 11.0); // was 10.0
    assert_eq!(mat.get_val(1, 0).unwrap(), 8.0);  // was 7.0
    assert_eq!(mat.get_val(1, 1).unwrap(), 9.0);  // was 8.0
}

#[test]
fn test_generated_matrices() {
    // Test with multiple sizes to show parameterization
    for (n, m, start) in [(1, 1, 0.0), (2, 3, 1.0), (3, 2, -2.0), (4, 4, 5.0)] {
        let mat = generate_matrix(m, n, start);
        assert_eq!(mat.n, n);
        assert_eq!(mat.m, m);

        // Check that values are consecutive from start
        let raw = mat.get_raw_values();
        for (idx, val) in raw.iter().enumerate() {
            let expected = start + idx as F;
            assert!(compare_equal_f(*val, expected));
        }
    }
}

#[test]
fn test_matrix_addition_substraction_scalar_multiplication() {
    let out = &generate_matrix(2, 3, 0.0) + &generate_matrix(2, 3, 6.0);
    
    let expected = Matrix::from_values(vec![
        6.0, 8.0, 10.0, 12.0, 14.0, 16.0
    ], 2, 3);

    assert!(out == expected);

    let mut out = &generate_matrix(2, 3, 0.0) - &generate_matrix(2, 3, 6.0);


    let expected = Matrix::from_values(vec![-6.0;6], 2, 3);

    assert!(out == expected);

    out = &out * 5.0;
    
    let expected = Matrix::from_values(vec![-30.0;6], 2, 3);

    assert!(out == expected);
}
